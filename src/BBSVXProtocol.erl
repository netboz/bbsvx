%% Generated by the Erlang ASN.1 BER compiler. Version: 5.2.1
%% Purpose: Encoding and decoding of the types in BBSVXProtocol.

-module('BBSVXProtocol').
-compile(nowarn_unused_vars).
-dialyzer(no_improper_lists).
-dialyzer(no_match).
-asn1_info([{vsn,'5.2.1'},
            {module,'BBSVXProtocol'},
            {options,[{i,"/home/yan/src/bbsvx/asn1/../src"},
 warnings,ber,errors,
 {cwd,"/home/yan/src/bbsvx/asn1"},
 {outdir,"/home/yan/src/bbsvx/asn1/../src"},
 {i,"/home/yan/src/bbsvx/asn1/."},
 maps,ber,
 {i,"."},
 {i,"/home/yan/src/bbsvx/asn1"}]}]).

-export([encoding_rule/0,maps/0,bit_string_format/0,
         legacy_erlang_types/0]).
-export(['dialyzer-suppressions'/1]).
-export([
enc_ProtocolVersion/2,
enc_NodeId/2,
enc_ULId/2,
enc_Lock/2,
enc_Namespace/2,
enc_Timestamp/2,
enc_PortNumber/2,
enc_HostAddress/2,
enc_NodeEntry/2,
enc_ExchangeEntry/2,
enc_ConnectionResult/2,
enc_RegistrationResult/2,
enc_DisconnectReason/2,
enc_HeaderConnect/2,
enc_HeaderConnectAck/2,
enc_HeaderRegister/2,
enc_HeaderRegisterAck/2,
enc_HeaderJoin/2,
enc_HeaderJoinAck/2,
enc_HeaderForwardJoin/2,
enc_HeaderForwardJoinAck/2,
enc_ExchangeIn/2,
enc_ExchangeOut/2,
enc_ExchangeAccept/2,
enc_ExchangeCancelled/2,
enc_NodeQuitting/2,
enc_ChangeLock/2,
enc_OntologyHistory/2,
enc_EptoMessage/2,
enc_SendForwardSubscription/2,
enc_OpenForwardJoin/2,
enc_BBSVXMessage/2
]).

-export([
dec_ProtocolVersion/2,
dec_NodeId/2,
dec_ULId/2,
dec_Lock/2,
dec_Namespace/2,
dec_Timestamp/2,
dec_PortNumber/2,
dec_HostAddress/2,
dec_NodeEntry/2,
dec_ExchangeEntry/2,
dec_ConnectionResult/2,
dec_RegistrationResult/2,
dec_DisconnectReason/2,
dec_HeaderConnect/2,
dec_HeaderConnectAck/2,
dec_HeaderRegister/2,
dec_HeaderRegisterAck/2,
dec_HeaderJoin/2,
dec_HeaderJoinAck/2,
dec_HeaderForwardJoin/2,
dec_HeaderForwardJoinAck/2,
dec_ExchangeIn/2,
dec_ExchangeOut/2,
dec_ExchangeAccept/2,
dec_ExchangeCancelled/2,
dec_NodeQuitting/2,
dec_ChangeLock/2,
dec_OntologyHistory/2,
dec_EptoMessage/2,
dec_SendForwardSubscription/2,
dec_OpenForwardJoin/2,
dec_BBSVXMessage/2
]).

-export([info/0]).

-export([encode/2,decode/2]).

encoding_rule() -> ber.

maps() -> true.

bit_string_format() -> bitstring.

legacy_erlang_types() -> false.

encode(Type, Data) ->
try iolist_to_binary(element(1, encode_disp(Type, Data))) of
  Bytes ->
    {ok,Bytes}
  catch
    Class:Exception:Stk when Class =:= error; Class =:= exit ->
      case Exception of
        {error,{asn1,Reason}} ->
          {error,{asn1,{Reason,Stk}}};
        Reason ->
         {error,{asn1,{Reason,Stk}}}
      end
end.

decode(Type, Data) ->
try
   Result = decode_disp(Type, element(1, ber_decode_nif(Data))),
   {ok,Result}
  catch
    Class:Exception:Stk when Class =:= error; Class =:= exit ->
      case Exception of
        {error,{asn1,Reason}} ->
          {error,{asn1,{Reason,Stk}}};
        Reason ->
         {error,{asn1,{Reason,Stk}}}
      end
end.

encode_disp('ProtocolVersion', Data) -> enc_ProtocolVersion(Data);
encode_disp('NodeId', Data) -> enc_NodeId(Data);
encode_disp('ULId', Data) -> enc_ULId(Data);
encode_disp('Lock', Data) -> enc_Lock(Data);
encode_disp('Namespace', Data) -> enc_Namespace(Data);
encode_disp('Timestamp', Data) -> enc_Timestamp(Data);
encode_disp('PortNumber', Data) -> enc_PortNumber(Data);
encode_disp('HostAddress', Data) -> enc_HostAddress(Data);
encode_disp('NodeEntry', Data) -> enc_NodeEntry(Data);
encode_disp('ExchangeEntry', Data) -> enc_ExchangeEntry(Data);
encode_disp('ConnectionResult', Data) -> enc_ConnectionResult(Data);
encode_disp('RegistrationResult', Data) -> enc_RegistrationResult(Data);
encode_disp('DisconnectReason', Data) -> enc_DisconnectReason(Data);
encode_disp('HeaderConnect', Data) -> enc_HeaderConnect(Data);
encode_disp('HeaderConnectAck', Data) -> enc_HeaderConnectAck(Data);
encode_disp('HeaderRegister', Data) -> enc_HeaderRegister(Data);
encode_disp('HeaderRegisterAck', Data) -> enc_HeaderRegisterAck(Data);
encode_disp('HeaderJoin', Data) -> enc_HeaderJoin(Data);
encode_disp('HeaderJoinAck', Data) -> enc_HeaderJoinAck(Data);
encode_disp('HeaderForwardJoin', Data) -> enc_HeaderForwardJoin(Data);
encode_disp('HeaderForwardJoinAck', Data) -> enc_HeaderForwardJoinAck(Data);
encode_disp('ExchangeIn', Data) -> enc_ExchangeIn(Data);
encode_disp('ExchangeOut', Data) -> enc_ExchangeOut(Data);
encode_disp('ExchangeAccept', Data) -> enc_ExchangeAccept(Data);
encode_disp('ExchangeCancelled', Data) -> enc_ExchangeCancelled(Data);
encode_disp('NodeQuitting', Data) -> enc_NodeQuitting(Data);
encode_disp('ChangeLock', Data) -> enc_ChangeLock(Data);
encode_disp('OntologyHistory', Data) -> enc_OntologyHistory(Data);
encode_disp('EptoMessage', Data) -> enc_EptoMessage(Data);
encode_disp('SendForwardSubscription', Data) -> enc_SendForwardSubscription(Data);
encode_disp('OpenForwardJoin', Data) -> enc_OpenForwardJoin(Data);
encode_disp('BBSVXMessage', Data) -> enc_BBSVXMessage(Data);
encode_disp(Type, _Data) -> exit({error,{asn1,{undefined_type,Type}}}).

decode_disp('ProtocolVersion', Data) -> dec_ProtocolVersion(Data);
decode_disp('NodeId', Data) -> dec_NodeId(Data);
decode_disp('ULId', Data) -> dec_ULId(Data);
decode_disp('Lock', Data) -> dec_Lock(Data);
decode_disp('Namespace', Data) -> dec_Namespace(Data);
decode_disp('Timestamp', Data) -> dec_Timestamp(Data);
decode_disp('PortNumber', Data) -> dec_PortNumber(Data);
decode_disp('HostAddress', Data) -> dec_HostAddress(Data);
decode_disp('NodeEntry', Data) -> dec_NodeEntry(Data);
decode_disp('ExchangeEntry', Data) -> dec_ExchangeEntry(Data);
decode_disp('ConnectionResult', Data) -> dec_ConnectionResult(Data);
decode_disp('RegistrationResult', Data) -> dec_RegistrationResult(Data);
decode_disp('DisconnectReason', Data) -> dec_DisconnectReason(Data);
decode_disp('HeaderConnect', Data) -> dec_HeaderConnect(Data);
decode_disp('HeaderConnectAck', Data) -> dec_HeaderConnectAck(Data);
decode_disp('HeaderRegister', Data) -> dec_HeaderRegister(Data);
decode_disp('HeaderRegisterAck', Data) -> dec_HeaderRegisterAck(Data);
decode_disp('HeaderJoin', Data) -> dec_HeaderJoin(Data);
decode_disp('HeaderJoinAck', Data) -> dec_HeaderJoinAck(Data);
decode_disp('HeaderForwardJoin', Data) -> dec_HeaderForwardJoin(Data);
decode_disp('HeaderForwardJoinAck', Data) -> dec_HeaderForwardJoinAck(Data);
decode_disp('ExchangeIn', Data) -> dec_ExchangeIn(Data);
decode_disp('ExchangeOut', Data) -> dec_ExchangeOut(Data);
decode_disp('ExchangeAccept', Data) -> dec_ExchangeAccept(Data);
decode_disp('ExchangeCancelled', Data) -> dec_ExchangeCancelled(Data);
decode_disp('NodeQuitting', Data) -> dec_NodeQuitting(Data);
decode_disp('ChangeLock', Data) -> dec_ChangeLock(Data);
decode_disp('OntologyHistory', Data) -> dec_OntologyHistory(Data);
decode_disp('EptoMessage', Data) -> dec_EptoMessage(Data);
decode_disp('SendForwardSubscription', Data) -> dec_SendForwardSubscription(Data);
decode_disp('OpenForwardJoin', Data) -> dec_OpenForwardJoin(Data);
decode_disp('BBSVXMessage', Data) -> dec_BBSVXMessage(Data);
decode_disp(Type, _Data) -> exit({error,{asn1,{undefined_type,Type}}}).

info() ->
   case ?MODULE:module_info(attributes) of
     Attributes when is_list(Attributes) ->
       case lists:keyfind(asn1_info, 1, Attributes) of
         {_,Info} when is_list(Info) ->
           Info;
         _ ->
           []
       end;
     _ ->
       []
   end.


%%================================
%%  ProtocolVersion
%%================================
enc_ProtocolVersion(Val) ->
    enc_ProtocolVersion(Val, [<<12>>]).

enc_ProtocolVersion(Val, TagIn) ->
encode_UTF8_string(Val, TagIn).


dec_ProtocolVersion(Tlv) ->
   dec_ProtocolVersion(Tlv, [12]).

dec_ProtocolVersion(Tlv, TagIn) ->
decode_UTF8_string(Tlv, TagIn).



%%================================
%%  NodeId
%%================================
enc_NodeId(Val) ->
    enc_NodeId(Val, [<<4>>]).

enc_NodeId(Val, TagIn) ->
encode_restricted_string(Val, TagIn).


dec_NodeId(Tlv) ->
   dec_NodeId(Tlv, [4]).

dec_NodeId(Tlv, TagIn) ->
begin
Val1 = decode_octet_string(Tlv, TagIn),
C1 = byte_size(Val1),
if 32 =< C1, C1 =< 64 ->
Val1;
true ->
exit({error,{asn1,bad_range}})
end
end.



%%================================
%%  ULId
%%================================
enc_ULId(Val) ->
    enc_ULId(Val, [<<4>>]).

enc_ULId(Val, TagIn) ->
encode_restricted_string(Val, TagIn).


dec_ULId(Tlv) ->
   dec_ULId(Tlv, [4]).

dec_ULId(Tlv, TagIn) ->
begin
Val1 = decode_octet_string(Tlv, TagIn),
C1 = byte_size(Val1),
if C1 =:= 26 ->
Val1;
true ->
exit({error,{asn1,bad_range}})
end
end.



%%================================
%%  Lock
%%================================
enc_Lock(Val) ->
    enc_Lock(Val, [<<4>>]).

enc_Lock(Val, TagIn) ->
encode_restricted_string(Val, TagIn).


dec_Lock(Tlv) ->
   dec_Lock(Tlv, [4]).

dec_Lock(Tlv, TagIn) ->
begin
Val1 = decode_octet_string(Tlv, TagIn),
C1 = byte_size(Val1),
if C1 =:= 24 ->
Val1;
true ->
exit({error,{asn1,bad_range}})
end
end.



%%================================
%%  Namespace
%%================================
enc_Namespace(Val) ->
    enc_Namespace(Val, [<<12>>]).

enc_Namespace(Val, TagIn) ->
encode_UTF8_string(Val, TagIn).


dec_Namespace(Tlv) ->
   dec_Namespace(Tlv, [12]).

dec_Namespace(Tlv, TagIn) ->
decode_UTF8_string(Tlv, TagIn).



%%================================
%%  Timestamp
%%================================
enc_Timestamp(Val) ->
    enc_Timestamp(Val, [<<2>>]).

enc_Timestamp(Val, TagIn) ->
encode_integer(Val, TagIn).


dec_Timestamp(Tlv) ->
   dec_Timestamp(Tlv, [2]).

dec_Timestamp(Tlv, TagIn) ->
begin
Val1 = decode_integer(Tlv, TagIn),
if 0 =< Val1, Val1 =< 'MAX' ->
Val1;
true ->
exit({error,{asn1,bad_range}})
end
end.



%%================================
%%  PortNumber
%%================================
enc_PortNumber(Val) ->
    enc_PortNumber(Val, [<<2>>]).

enc_PortNumber(Val, TagIn) ->
encode_integer(Val, TagIn).


dec_PortNumber(Tlv) ->
   dec_PortNumber(Tlv, [2]).

dec_PortNumber(Tlv, TagIn) ->
begin
Val1 = decode_integer(Tlv, TagIn),
if 1 =< Val1, Val1 =< 65535 ->
Val1;
true ->
exit({error,{asn1,bad_range}})
end
end.



%%================================
%%  HostAddress
%%================================
enc_HostAddress(Val) ->
    enc_HostAddress(Val, []).

enc_HostAddress(Val, TagIn) ->
   {EncBytes,EncLen} = case element(1,Val) of
      ipv4 ->
         encode_restricted_string(element(2,Val), [<<128>>]);
      ipv6 ->
         encode_restricted_string(element(2,Val), [<<129>>]);
      hostname ->
         encode_UTF8_string(element(2,Val), [<<130>>]);
      local ->
         encode_null(element(2,Val), [<<131>>]);
      Else -> 
         exit({error,{asn1,{invalid_choice_type,Else}}})
   end,

encode_tags(TagIn, EncBytes, EncLen).




dec_HostAddress(Tlv) ->
   dec_HostAddress(Tlv, []).

dec_HostAddress(Tlv, TagIn) ->
Tlv1 = match_tags(Tlv, TagIn),
case (case Tlv1 of [CtempTlv1] -> CtempTlv1; _ -> Tlv1 end) of

%% 'ipv4'
    {131072, V1} -> 
        {ipv4, begin
Val1 = decode_octet_string(V1, []),
C1 = byte_size(Val1),
if C1 =:= 4 ->
Val1;
true ->
exit({error,{asn1,bad_range}})
end
end};


%% 'ipv6'
    {131073, V1} -> 
        {ipv6, begin
Val2 = decode_octet_string(V1, []),
C2 = byte_size(Val2),
if C2 =:= 16 ->
Val2;
true ->
exit({error,{asn1,bad_range}})
end
end};


%% 'hostname'
    {131074, V1} -> 
        {hostname, decode_UTF8_string(V1, [])};


%% 'local'
    {131075, V1} -> 
        {local, decode_null(V1, [])};

      Else -> 
         exit({error,{asn1,{invalid_choice_tag,Else}}})
   end
.


%%================================
%%  NodeEntry
%%================================
enc_NodeEntry(Val) ->
    enc_NodeEntry(Val, [<<48>>]).

enc_NodeEntry(Val, TagIn) ->
#{host:=Cindex2} = Val,
Cindex1 = case Val of
  #{nodeId:=Cindex1_0} -> Cindex1_0;
  _ -> asn1__MISSING_IN_MAP
end,
Cindex3 = case Val of
  #{port:=Cindex3_0} -> Cindex3_0;
  _ -> asn1__MISSING_IN_MAP
end,

%%-------------------------------------------------
%% attribute nodeId(1) with type OCTET STRING OPTIONAL
%%-------------------------------------------------
   {EncBytes1,EncLen1} =  case Cindex1 of
         asn1__MISSING_IN_MAP -> {<<>>,0};
         _ ->
            encode_restricted_string(Cindex1, [<<128>>])
       end,

%%-------------------------------------------------
%% attribute host(2)   External BBSVXProtocol:HostAddress
%%-------------------------------------------------
   {EncBytes2,EncLen2} = 'enc_HostAddress'(Cindex2, [<<161>>]),

%%-------------------------------------------------
%% attribute port(3) with type INTEGER DEFAULT = 2304
%%-------------------------------------------------
   {EncBytes3,EncLen3} =  case Cindex3 of
         asn1__MISSING_IN_MAP ->
            {<<>>,0};
         _ when Cindex3 =:= 2304 ->
            {<<>>,0};
         _ ->
            encode_integer(Cindex3, [<<130>>])
       end,

   BytesSoFar = [EncBytes1, EncBytes2, EncBytes3],
LenSoFar = EncLen1 + EncLen2 + EncLen3,
encode_tags(TagIn, BytesSoFar, LenSoFar).


dec_NodeEntry(Tlv) ->
   dec_NodeEntry(Tlv, [16]).

dec_NodeEntry(Tlv, TagIn) ->
   %%-------------------------------------------------
   %% decode tag and length 
   %%-------------------------------------------------
Tlv1 = match_tags(Tlv, TagIn),

%%-------------------------------------------------
%% attribute nodeId(1) with type OCTET STRING OPTIONAL
%%-------------------------------------------------
{Term1,Tlv2} = case Tlv1 of
[{131072,V1}|TempTlv2] ->
    {begin
Val1 = decode_octet_string(V1, []),
C1 = byte_size(Val1),
if 32 =< C1, C1 =< 64 ->
Val1;
true ->
exit({error,{asn1,bad_range}})
end
end, TempTlv2};
    _ ->
        { asn1_NOVALUE, Tlv1}
end,

%%-------------------------------------------------
%% attribute host(2)   External BBSVXProtocol:HostAddress
%%-------------------------------------------------
[V2|Tlv3] = Tlv2, 
Term2 = 'dec_HostAddress'(V2, [131073]),

%%-------------------------------------------------
%% attribute port(3) with type INTEGER DEFAULT = 2304
%%-------------------------------------------------
{Term3,Tlv4} = case Tlv3 of
[{131074,V3}|TempTlv4] ->
    {begin
Val2 = decode_integer(V3, []),
if 1 =< Val2, Val2 =< 65535 ->
Val2;
true ->
exit({error,{asn1,bad_range}})
end
end, TempTlv4};
    _ ->
        {2304,Tlv3}
end,

case Tlv4 of
[] -> true;_ -> exit({error,{asn1, {unexpected,Tlv4}}}) % extra fields not allowed
end,
Res1 = #{host=>Term2,port=>Term3},
Res2 = case Term1 of
  asn1_NOVALUE -> Res1;
  _ -> Res1#{nodeId=>Term1}
end,
Res2.


%%================================
%%  ExchangeEntry
%%================================
enc_ExchangeEntry(Val) ->
    enc_ExchangeEntry(Val, [<<48>>]).

enc_ExchangeEntry(Val, TagIn) ->
#{ulid:=Cindex1,lock:=Cindex2,target:=Cindex3} = Val,
Cindex4 = case Val of
  #{newLock:=Cindex4_0} -> Cindex4_0;
  _ -> asn1__MISSING_IN_MAP
end,

%%-------------------------------------------------
%% attribute ulid(1) with type OCTET STRING
%%-------------------------------------------------
   {EncBytes1,EncLen1} = encode_restricted_string(Cindex1, [<<128>>]),

%%-------------------------------------------------
%% attribute lock(2) with type OCTET STRING
%%-------------------------------------------------
   {EncBytes2,EncLen2} = encode_restricted_string(Cindex2, [<<129>>]),

%%-------------------------------------------------
%% attribute target(3)   External BBSVXProtocol:NodeEntry
%%-------------------------------------------------
   {EncBytes3,EncLen3} = 'enc_NodeEntry'(Cindex3, [<<162>>]),

%%-------------------------------------------------
%% attribute newLock(4) with type OCTET STRING OPTIONAL
%%-------------------------------------------------
   {EncBytes4,EncLen4} =  case Cindex4 of
         asn1__MISSING_IN_MAP -> {<<>>,0};
         _ ->
            encode_restricted_string(Cindex4, [<<131>>])
       end,

   BytesSoFar = [EncBytes1, EncBytes2, EncBytes3, EncBytes4],
LenSoFar = EncLen1 + EncLen2 + EncLen3 + EncLen4,
encode_tags(TagIn, BytesSoFar, LenSoFar).


dec_ExchangeEntry(Tlv) ->
   dec_ExchangeEntry(Tlv, [16]).

dec_ExchangeEntry(Tlv, TagIn) ->
   %%-------------------------------------------------
   %% decode tag and length 
   %%-------------------------------------------------
Tlv1 = match_tags(Tlv, TagIn),

%%-------------------------------------------------
%% attribute ulid(1) with type OCTET STRING
%%-------------------------------------------------
[V1|Tlv2] = Tlv1, 
Term1 = begin
Val1 = decode_octet_string(V1, [131072]),
C1 = byte_size(Val1),
if C1 =:= 26 ->
Val1;
true ->
exit({error,{asn1,bad_range}})
end
end,

%%-------------------------------------------------
%% attribute lock(2) with type OCTET STRING
%%-------------------------------------------------
[V2|Tlv3] = Tlv2, 
Term2 = begin
Val2 = decode_octet_string(V2, [131073]),
C2 = byte_size(Val2),
if C2 =:= 24 ->
Val2;
true ->
exit({error,{asn1,bad_range}})
end
end,

%%-------------------------------------------------
%% attribute target(3)   External BBSVXProtocol:NodeEntry
%%-------------------------------------------------
[V3|Tlv4] = Tlv3, 
Term3 = 'dec_NodeEntry'(V3, [131074]),

%%-------------------------------------------------
%% attribute newLock(4) with type OCTET STRING OPTIONAL
%%-------------------------------------------------
{Term4,Tlv5} = case Tlv4 of
[{131075,V4}|TempTlv5] ->
    {begin
Val3 = decode_octet_string(V4, []),
C3 = byte_size(Val3),
if C3 =:= 24 ->
Val3;
true ->
exit({error,{asn1,bad_range}})
end
end, TempTlv5};
    _ ->
        { asn1_NOVALUE, Tlv4}
end,

case Tlv5 of
[] -> true;_ -> exit({error,{asn1, {unexpected,Tlv5}}}) % extra fields not allowed
end,
Res1 = #{ulid=>Term1,lock=>Term2,target=>Term3},
Res2 = case Term4 of
  asn1_NOVALUE -> Res1;
  _ -> Res1#{newLock=>Term4}
end,
Res2.


%%================================
%%  ConnectionResult
%%================================
enc_ConnectionResult(Val) ->
    enc_ConnectionResult(Val, [<<10>>]).

enc_ConnectionResult(Val, TagIn) ->
case Val of
ok -> encode_tags(TagIn, [0], 1);
'connection-to-self' -> encode_tags(TagIn, [1], 1);
'namespace-mismatch' -> encode_tags(TagIn, [2], 1);
'protocol-error' -> encode_tags(TagIn, [3], 1);
timeout -> encode_tags(TagIn, [4], 1);
'resource-exhausted' -> encode_tags(TagIn, [5], 1);
Enumval1 -> exit({error,{asn1, {enumerated_not_in_range,Enumval1}}})
end.


dec_ConnectionResult(Tlv) ->
   dec_ConnectionResult(Tlv, [10]).

dec_ConnectionResult(Tlv, TagIn) ->
case decode_integer(Tlv, TagIn) of
0 -> ok;
1 -> 'connection-to-self';
2 -> 'namespace-mismatch';
3 -> 'protocol-error';
4 -> timeout;
5 -> 'resource-exhausted';
Default1 -> exit({error,{asn1,{illegal_enumerated,Default1}}})
end.



%%================================
%%  RegistrationResult
%%================================
enc_RegistrationResult(Val) ->
    enc_RegistrationResult(Val, [<<10>>]).

enc_RegistrationResult(Val, TagIn) ->
case Val of
ok -> encode_tags(TagIn, [0], 1);
'namespace-full' -> encode_tags(TagIn, [1], 1);
'duplicate-node' -> encode_tags(TagIn, [2], 1);
'invalid-lock' -> encode_tags(TagIn, [3], 1);
'leader-unavailable' -> encode_tags(TagIn, [4], 1);
Enumval1 -> exit({error,{asn1, {enumerated_not_in_range,Enumval1}}})
end.


dec_RegistrationResult(Tlv) ->
   dec_RegistrationResult(Tlv, [10]).

dec_RegistrationResult(Tlv, TagIn) ->
case decode_integer(Tlv, TagIn) of
0 -> ok;
1 -> 'namespace-full';
2 -> 'duplicate-node';
3 -> 'invalid-lock';
4 -> 'leader-unavailable';
Default1 -> exit({error,{asn1,{illegal_enumerated,Default1}}})
end.



%%================================
%%  DisconnectReason
%%================================
enc_DisconnectReason(Val) ->
    enc_DisconnectReason(Val, [<<10>>]).

enc_DisconnectReason(Val, TagIn) ->
case Val of
normal -> encode_tags(TagIn, [0], 1);
'protocol-error' -> encode_tags(TagIn, [1], 1);
timeout -> encode_tags(TagIn, [2], 1);
'resource-limit' -> encode_tags(TagIn, [3], 1);
'network-error' -> encode_tags(TagIn, [4], 1);
shutdown -> encode_tags(TagIn, [5], 1);
Enumval1 -> exit({error,{asn1, {enumerated_not_in_range,Enumval1}}})
end.


dec_DisconnectReason(Tlv) ->
   dec_DisconnectReason(Tlv, [10]).

dec_DisconnectReason(Tlv, TagIn) ->
case decode_integer(Tlv, TagIn) of
0 -> normal;
1 -> 'protocol-error';
2 -> timeout;
3 -> 'resource-limit';
4 -> 'network-error';
5 -> shutdown;
Default1 -> exit({error,{asn1,{illegal_enumerated,Default1}}})
end.



%%================================
%%  HeaderConnect
%%================================
enc_HeaderConnect(Val) ->
    enc_HeaderConnect(Val, [<<48>>]).

enc_HeaderConnect(Val, TagIn) ->
#{nodeId:=Cindex3,namespace:=Cindex4} = Val,
Cindex1 = case Val of
  #{version:=Cindex1_0} -> Cindex1_0;
  _ -> asn1__MISSING_IN_MAP
end,
Cindex2 = case Val of
  #{connectionType:=Cindex2_0} -> Cindex2_0;
  _ -> asn1__MISSING_IN_MAP
end,

%%-------------------------------------------------
%% attribute version(1) with type UTF8String DEFAULT = [48,46,49,46,48]
%%-------------------------------------------------
   {EncBytes1,EncLen1} =  case Cindex1 of
         asn1__MISSING_IN_MAP ->
            {<<>>,0};
         _ when Cindex1 =:= [48,46,49,46,48] ->
            {<<>>,0};
         _ ->
            encode_UTF8_string(Cindex1, [<<128>>])
       end,

%%-------------------------------------------------
%% attribute connectionType(2) with type UTF8String OPTIONAL
%%-------------------------------------------------
   {EncBytes2,EncLen2} =  case Cindex2 of
         asn1__MISSING_IN_MAP -> {<<>>,0};
         _ ->
            encode_UTF8_string(Cindex2, [<<129>>])
       end,

%%-------------------------------------------------
%% attribute nodeId(3) with type OCTET STRING
%%-------------------------------------------------
   {EncBytes3,EncLen3} = encode_restricted_string(Cindex3, [<<130>>]),

%%-------------------------------------------------
%% attribute namespace(4) with type UTF8String
%%-------------------------------------------------
   {EncBytes4,EncLen4} = encode_UTF8_string(Cindex4, [<<131>>]),

   BytesSoFar = [EncBytes1, EncBytes2, EncBytes3, EncBytes4],
LenSoFar = EncLen1 + EncLen2 + EncLen3 + EncLen4,
encode_tags(TagIn, BytesSoFar, LenSoFar).


dec_HeaderConnect(Tlv) ->
   dec_HeaderConnect(Tlv, [16]).

dec_HeaderConnect(Tlv, TagIn) ->
   %%-------------------------------------------------
   %% decode tag and length 
   %%-------------------------------------------------
Tlv1 = match_tags(Tlv, TagIn),

%%-------------------------------------------------
%% attribute version(1) with type UTF8String DEFAULT = [48,46,49,46,48]
%%-------------------------------------------------
{Term1,Tlv2} = case Tlv1 of
[{131072,V1}|TempTlv2] ->
    {decode_UTF8_string(V1, []), TempTlv2};
    _ ->
        {[48,46,49,46,48],Tlv1}
end,

%%-------------------------------------------------
%% attribute connectionType(2) with type UTF8String OPTIONAL
%%-------------------------------------------------
{Term2,Tlv3} = case Tlv2 of
[{131073,V2}|TempTlv3] ->
    {decode_UTF8_string(V2, []), TempTlv3};
    _ ->
        { asn1_NOVALUE, Tlv2}
end,

%%-------------------------------------------------
%% attribute nodeId(3) with type OCTET STRING
%%-------------------------------------------------
[V3|Tlv4] = Tlv3, 
Term3 = begin
Val1 = decode_octet_string(V3, [131074]),
C1 = byte_size(Val1),
if 32 =< C1, C1 =< 64 ->
Val1;
true ->
exit({error,{asn1,bad_range}})
end
end,

%%-------------------------------------------------
%% attribute namespace(4) with type UTF8String
%%-------------------------------------------------
[V4|Tlv5] = Tlv4, 
Term4 = decode_UTF8_string(V4, [131075]),

case Tlv5 of
[] -> true;_ -> exit({error,{asn1, {unexpected,Tlv5}}}) % extra fields not allowed
end,
Res1 = #{version=>Term1,nodeId=>Term3,namespace=>Term4},
Res2 = case Term2 of
  asn1_NOVALUE -> Res1;
  _ -> Res1#{connectionType=>Term2}
end,
Res2.


%%================================
%%  HeaderConnectAck
%%================================
enc_HeaderConnectAck(Val) ->
    enc_HeaderConnectAck(Val, [<<48>>]).

enc_HeaderConnectAck(Val, TagIn) ->
#{result:=Cindex1,nodeId:=Cindex2} = Val,

%%-------------------------------------------------
%% attribute result(1) with type ENUMERATED
%%-------------------------------------------------
   {EncBytes1,EncLen1} = case Cindex1 of
ok -> encode_tags([<<128>>], [0], 1);
'connection-to-self' -> encode_tags([<<128>>], [1], 1);
'namespace-mismatch' -> encode_tags([<<128>>], [2], 1);
'protocol-error' -> encode_tags([<<128>>], [3], 1);
timeout -> encode_tags([<<128>>], [4], 1);
'resource-exhausted' -> encode_tags([<<128>>], [5], 1);
Enumval1 -> exit({error,{asn1, {enumerated_not_in_range,Enumval1}}})
end,

%%-------------------------------------------------
%% attribute nodeId(2) with type OCTET STRING
%%-------------------------------------------------
   {EncBytes2,EncLen2} = encode_restricted_string(Cindex2, [<<129>>]),

   BytesSoFar = [EncBytes1, EncBytes2],
LenSoFar = EncLen1 + EncLen2,
encode_tags(TagIn, BytesSoFar, LenSoFar).


dec_HeaderConnectAck(Tlv) ->
   dec_HeaderConnectAck(Tlv, [16]).

dec_HeaderConnectAck(Tlv, TagIn) ->
   %%-------------------------------------------------
   %% decode tag and length 
   %%-------------------------------------------------
Tlv1 = match_tags(Tlv, TagIn),

%%-------------------------------------------------
%% attribute result(1) with type ENUMERATED
%%-------------------------------------------------
[V1|Tlv2] = Tlv1, 
Term1 = case decode_integer(V1, [131072]) of
0 -> ok;
1 -> 'connection-to-self';
2 -> 'namespace-mismatch';
3 -> 'protocol-error';
4 -> timeout;
5 -> 'resource-exhausted';
Default1 -> exit({error,{asn1,{illegal_enumerated,Default1}}})
end,

%%-------------------------------------------------
%% attribute nodeId(2) with type OCTET STRING
%%-------------------------------------------------
[V2|Tlv3] = Tlv2, 
Term2 = begin
Val1 = decode_octet_string(V2, [131073]),
C1 = byte_size(Val1),
if 32 =< C1, C1 =< 64 ->
Val1;
true ->
exit({error,{asn1,bad_range}})
end
end,

case Tlv3 of
[] -> true;_ -> exit({error,{asn1, {unexpected,Tlv3}}}) % extra fields not allowed
end,
Res1 = #{result=>Term1,nodeId=>Term2},
Res1.


%%================================
%%  HeaderRegister
%%================================
enc_HeaderRegister(Val) ->
    enc_HeaderRegister(Val, [<<48>>]).

enc_HeaderRegister(Val, TagIn) ->
#{namespace:=Cindex1,ulid:=Cindex2,lock:=Cindex3} = Val,

%%-------------------------------------------------
%% attribute namespace(1) with type UTF8String
%%-------------------------------------------------
   {EncBytes1,EncLen1} = encode_UTF8_string(Cindex1, [<<128>>]),

%%-------------------------------------------------
%% attribute ulid(2) with type OCTET STRING
%%-------------------------------------------------
   {EncBytes2,EncLen2} = encode_restricted_string(Cindex2, [<<129>>]),

%%-------------------------------------------------
%% attribute lock(3) with type OCTET STRING
%%-------------------------------------------------
   {EncBytes3,EncLen3} = encode_restricted_string(Cindex3, [<<130>>]),

   BytesSoFar = [EncBytes1, EncBytes2, EncBytes3],
LenSoFar = EncLen1 + EncLen2 + EncLen3,
encode_tags(TagIn, BytesSoFar, LenSoFar).


dec_HeaderRegister(Tlv) ->
   dec_HeaderRegister(Tlv, [16]).

dec_HeaderRegister(Tlv, TagIn) ->
   %%-------------------------------------------------
   %% decode tag and length 
   %%-------------------------------------------------
Tlv1 = match_tags(Tlv, TagIn),

%%-------------------------------------------------
%% attribute namespace(1) with type UTF8String
%%-------------------------------------------------
[V1|Tlv2] = Tlv1, 
Term1 = decode_UTF8_string(V1, [131072]),

%%-------------------------------------------------
%% attribute ulid(2) with type OCTET STRING
%%-------------------------------------------------
[V2|Tlv3] = Tlv2, 
Term2 = begin
Val1 = decode_octet_string(V2, [131073]),
C1 = byte_size(Val1),
if C1 =:= 26 ->
Val1;
true ->
exit({error,{asn1,bad_range}})
end
end,

%%-------------------------------------------------
%% attribute lock(3) with type OCTET STRING
%%-------------------------------------------------
[V3|Tlv4] = Tlv3, 
Term3 = begin
Val2 = decode_octet_string(V3, [131074]),
C2 = byte_size(Val2),
if C2 =:= 24 ->
Val2;
true ->
exit({error,{asn1,bad_range}})
end
end,

case Tlv4 of
[] -> true;_ -> exit({error,{asn1, {unexpected,Tlv4}}}) % extra fields not allowed
end,
Res1 = #{namespace=>Term1,ulid=>Term2,lock=>Term3},
Res1.


%%================================
%%  HeaderRegisterAck
%%================================
enc_HeaderRegisterAck(Val) ->
    enc_HeaderRegisterAck(Val, [<<48>>]).

enc_HeaderRegisterAck(Val, TagIn) ->
#{result:=Cindex1} = Val,
Cindex2 = case Val of
  #{leader:=Cindex2_0} -> Cindex2_0;
  _ -> asn1__MISSING_IN_MAP
end,
Cindex3 = case Val of
  #{currentIndex:=Cindex3_0} -> Cindex3_0;
  _ -> asn1__MISSING_IN_MAP
end,

%%-------------------------------------------------
%% attribute result(1) with type ENUMERATED
%%-------------------------------------------------
   {EncBytes1,EncLen1} = case Cindex1 of
ok -> encode_tags([<<128>>], [0], 1);
'namespace-full' -> encode_tags([<<128>>], [1], 1);
'duplicate-node' -> encode_tags([<<128>>], [2], 1);
'invalid-lock' -> encode_tags([<<128>>], [3], 1);
'leader-unavailable' -> encode_tags([<<128>>], [4], 1);
Enumval1 -> exit({error,{asn1, {enumerated_not_in_range,Enumval1}}})
end,

%%-------------------------------------------------
%% attribute leader(2) with type OCTET STRING OPTIONAL
%%-------------------------------------------------
   {EncBytes2,EncLen2} =  case Cindex2 of
         asn1__MISSING_IN_MAP -> {<<>>,0};
         _ ->
            encode_restricted_string(Cindex2, [<<129>>])
       end,

%%-------------------------------------------------
%% attribute currentIndex(3) with type INTEGER OPTIONAL
%%-------------------------------------------------
   {EncBytes3,EncLen3} =  case Cindex3 of
         asn1__MISSING_IN_MAP -> {<<>>,0};
         _ ->
            encode_integer(Cindex3, [<<130>>])
       end,

   BytesSoFar = [EncBytes1, EncBytes2, EncBytes3],
LenSoFar = EncLen1 + EncLen2 + EncLen3,
encode_tags(TagIn, BytesSoFar, LenSoFar).


dec_HeaderRegisterAck(Tlv) ->
   dec_HeaderRegisterAck(Tlv, [16]).

dec_HeaderRegisterAck(Tlv, TagIn) ->
   %%-------------------------------------------------
   %% decode tag and length 
   %%-------------------------------------------------
Tlv1 = match_tags(Tlv, TagIn),

%%-------------------------------------------------
%% attribute result(1) with type ENUMERATED
%%-------------------------------------------------
[V1|Tlv2] = Tlv1, 
Term1 = case decode_integer(V1, [131072]) of
0 -> ok;
1 -> 'namespace-full';
2 -> 'duplicate-node';
3 -> 'invalid-lock';
4 -> 'leader-unavailable';
Default1 -> exit({error,{asn1,{illegal_enumerated,Default1}}})
end,

%%-------------------------------------------------
%% attribute leader(2) with type OCTET STRING OPTIONAL
%%-------------------------------------------------
{Term2,Tlv3} = case Tlv2 of
[{131073,V2}|TempTlv3] ->
    {begin
Val1 = decode_octet_string(V2, []),
C1 = byte_size(Val1),
if 32 =< C1, C1 =< 64 ->
Val1;
true ->
exit({error,{asn1,bad_range}})
end
end, TempTlv3};
    _ ->
        { asn1_NOVALUE, Tlv2}
end,

%%-------------------------------------------------
%% attribute currentIndex(3) with type INTEGER OPTIONAL
%%-------------------------------------------------
{Term3,Tlv4} = case Tlv3 of
[{131074,V3}|TempTlv4] ->
    {decode_integer(V3, []), TempTlv4};
    _ ->
        { asn1_NOVALUE, Tlv3}
end,

case Tlv4 of
[] -> true;_ -> exit({error,{asn1, {unexpected,Tlv4}}}) % extra fields not allowed
end,
Res1 = #{result=>Term1},
Res2 = case Term2 of
  asn1_NOVALUE -> Res1;
  _ -> Res1#{leader=>Term2}
end,
Res3 = case Term3 of
  asn1_NOVALUE -> Res2;
  _ -> Res2#{currentIndex=>Term3}
end,
Res3.


%%================================
%%  HeaderJoin
%%================================
enc_HeaderJoin(Val) ->
    enc_HeaderJoin(Val, [<<48>>]).

enc_HeaderJoin(Val, TagIn) ->
#{namespace:=Cindex1,ulid:=Cindex2,joinType:=Cindex3,currentLock:=Cindex4,newLock:=Cindex5} = Val,
Cindex6 = case Val of
  #{options:=Cindex6_0} -> Cindex6_0;
  _ -> asn1__MISSING_IN_MAP
end,

%%-------------------------------------------------
%% attribute namespace(1) with type UTF8String
%%-------------------------------------------------
   {EncBytes1,EncLen1} = encode_UTF8_string(Cindex1, [<<128>>]),

%%-------------------------------------------------
%% attribute ulid(2) with type OCTET STRING
%%-------------------------------------------------
   {EncBytes2,EncLen2} = encode_restricted_string(Cindex2, [<<129>>]),

%%-------------------------------------------------
%% attribute joinType(3) with type UTF8String
%%-------------------------------------------------
   {EncBytes3,EncLen3} = encode_UTF8_string(Cindex3, [<<130>>]),

%%-------------------------------------------------
%% attribute currentLock(4) with type OCTET STRING
%%-------------------------------------------------
   {EncBytes4,EncLen4} = encode_restricted_string(Cindex4, [<<131>>]),

%%-------------------------------------------------
%% attribute newLock(5) with type OCTET STRING
%%-------------------------------------------------
   {EncBytes5,EncLen5} = encode_restricted_string(Cindex5, [<<132>>]),

%%-------------------------------------------------
%% attribute options(6) with type OCTET STRING OPTIONAL
%%-------------------------------------------------
   {EncBytes6,EncLen6} =  case Cindex6 of
         asn1__MISSING_IN_MAP -> {<<>>,0};
         _ ->
            encode_restricted_string(Cindex6, [<<133>>])
       end,

   BytesSoFar = [EncBytes1, EncBytes2, EncBytes3, EncBytes4, EncBytes5, EncBytes6],
LenSoFar = EncLen1 + EncLen2 + EncLen3 + EncLen4 + EncLen5 + EncLen6,
encode_tags(TagIn, BytesSoFar, LenSoFar).


dec_HeaderJoin(Tlv) ->
   dec_HeaderJoin(Tlv, [16]).

dec_HeaderJoin(Tlv, TagIn) ->
   %%-------------------------------------------------
   %% decode tag and length 
   %%-------------------------------------------------
Tlv1 = match_tags(Tlv, TagIn),

%%-------------------------------------------------
%% attribute namespace(1) with type UTF8String
%%-------------------------------------------------
[V1|Tlv2] = Tlv1, 
Term1 = decode_UTF8_string(V1, [131072]),

%%-------------------------------------------------
%% attribute ulid(2) with type OCTET STRING
%%-------------------------------------------------
[V2|Tlv3] = Tlv2, 
Term2 = begin
Val1 = decode_octet_string(V2, [131073]),
C1 = byte_size(Val1),
if C1 =:= 26 ->
Val1;
true ->
exit({error,{asn1,bad_range}})
end
end,

%%-------------------------------------------------
%% attribute joinType(3) with type UTF8String
%%-------------------------------------------------
[V3|Tlv4] = Tlv3, 
Term3 = decode_UTF8_string(V3, [131074]),

%%-------------------------------------------------
%% attribute currentLock(4) with type OCTET STRING
%%-------------------------------------------------
[V4|Tlv5] = Tlv4, 
Term4 = begin
Val2 = decode_octet_string(V4, [131075]),
C2 = byte_size(Val2),
if C2 =:= 24 ->
Val2;
true ->
exit({error,{asn1,bad_range}})
end
end,

%%-------------------------------------------------
%% attribute newLock(5) with type OCTET STRING
%%-------------------------------------------------
[V5|Tlv6] = Tlv5, 
Term5 = begin
Val3 = decode_octet_string(V5, [131076]),
C3 = byte_size(Val3),
if C3 =:= 24 ->
Val3;
true ->
exit({error,{asn1,bad_range}})
end
end,

%%-------------------------------------------------
%% attribute options(6) with type OCTET STRING OPTIONAL
%%-------------------------------------------------
{Term6,Tlv7} = case Tlv6 of
[{131077,V6}|TempTlv7] ->
    {decode_octet_string(V6, []), TempTlv7};
    _ ->
        { asn1_NOVALUE, Tlv6}
end,

case Tlv7 of
[] -> true;_ -> exit({error,{asn1, {unexpected,Tlv7}}}) % extra fields not allowed
end,
Res1 = #{namespace=>Term1,ulid=>Term2,joinType=>Term3,currentLock=>Term4,newLock=>Term5},
Res2 = case Term6 of
  asn1_NOVALUE -> Res1;
  _ -> Res1#{options=>Term6}
end,
Res2.


%%================================
%%  HeaderJoinAck
%%================================
enc_HeaderJoinAck(Val) ->
    enc_HeaderJoinAck(Val, [<<48>>]).

enc_HeaderJoinAck(Val, TagIn) ->
#{result:=Cindex1,joinType:=Cindex2} = Val,
Cindex3 = case Val of
  #{options:=Cindex3_0} -> Cindex3_0;
  _ -> asn1__MISSING_IN_MAP
end,

%%-------------------------------------------------
%% attribute result(1) with type ENUMERATED
%%-------------------------------------------------
   {EncBytes1,EncLen1} = case Cindex1 of
ok -> encode_tags([<<128>>], [0], 1);
'namespace-full' -> encode_tags([<<128>>], [1], 1);
'duplicate-node' -> encode_tags([<<128>>], [2], 1);
'invalid-lock' -> encode_tags([<<128>>], [3], 1);
'leader-unavailable' -> encode_tags([<<128>>], [4], 1);
Enumval1 -> exit({error,{asn1, {enumerated_not_in_range,Enumval1}}})
end,

%%-------------------------------------------------
%% attribute joinType(2) with type UTF8String
%%-------------------------------------------------
   {EncBytes2,EncLen2} = encode_UTF8_string(Cindex2, [<<129>>]),

%%-------------------------------------------------
%% attribute options(3) with type OCTET STRING OPTIONAL
%%-------------------------------------------------
   {EncBytes3,EncLen3} =  case Cindex3 of
         asn1__MISSING_IN_MAP -> {<<>>,0};
         _ ->
            encode_restricted_string(Cindex3, [<<130>>])
       end,

   BytesSoFar = [EncBytes1, EncBytes2, EncBytes3],
LenSoFar = EncLen1 + EncLen2 + EncLen3,
encode_tags(TagIn, BytesSoFar, LenSoFar).


dec_HeaderJoinAck(Tlv) ->
   dec_HeaderJoinAck(Tlv, [16]).

dec_HeaderJoinAck(Tlv, TagIn) ->
   %%-------------------------------------------------
   %% decode tag and length 
   %%-------------------------------------------------
Tlv1 = match_tags(Tlv, TagIn),

%%-------------------------------------------------
%% attribute result(1) with type ENUMERATED
%%-------------------------------------------------
[V1|Tlv2] = Tlv1, 
Term1 = case decode_integer(V1, [131072]) of
0 -> ok;
1 -> 'namespace-full';
2 -> 'duplicate-node';
3 -> 'invalid-lock';
4 -> 'leader-unavailable';
Default1 -> exit({error,{asn1,{illegal_enumerated,Default1}}})
end,

%%-------------------------------------------------
%% attribute joinType(2) with type UTF8String
%%-------------------------------------------------
[V2|Tlv3] = Tlv2, 
Term2 = decode_UTF8_string(V2, [131073]),

%%-------------------------------------------------
%% attribute options(3) with type OCTET STRING OPTIONAL
%%-------------------------------------------------
{Term3,Tlv4} = case Tlv3 of
[{131074,V3}|TempTlv4] ->
    {decode_octet_string(V3, []), TempTlv4};
    _ ->
        { asn1_NOVALUE, Tlv3}
end,

case Tlv4 of
[] -> true;_ -> exit({error,{asn1, {unexpected,Tlv4}}}) % extra fields not allowed
end,
Res1 = #{result=>Term1,joinType=>Term2},
Res2 = case Term3 of
  asn1_NOVALUE -> Res1;
  _ -> Res1#{options=>Term3}
end,
Res2.


%%================================
%%  HeaderForwardJoin
%%================================
enc_HeaderForwardJoin(Val) ->
    enc_HeaderForwardJoin(Val, [<<48>>]).

enc_HeaderForwardJoin(Val, TagIn) ->
#{namespace:=Cindex1,ulid:=Cindex2,joinType:=Cindex3,lock:=Cindex4} = Val,
Cindex5 = case Val of
  #{options:=Cindex5_0} -> Cindex5_0;
  _ -> asn1__MISSING_IN_MAP
end,

%%-------------------------------------------------
%% attribute namespace(1) with type UTF8String
%%-------------------------------------------------
   {EncBytes1,EncLen1} = encode_UTF8_string(Cindex1, [<<128>>]),

%%-------------------------------------------------
%% attribute ulid(2) with type OCTET STRING
%%-------------------------------------------------
   {EncBytes2,EncLen2} = encode_restricted_string(Cindex2, [<<129>>]),

%%-------------------------------------------------
%% attribute joinType(3) with type UTF8String
%%-------------------------------------------------
   {EncBytes3,EncLen3} = encode_UTF8_string(Cindex3, [<<130>>]),

%%-------------------------------------------------
%% attribute lock(4) with type OCTET STRING
%%-------------------------------------------------
   {EncBytes4,EncLen4} = encode_restricted_string(Cindex4, [<<131>>]),

%%-------------------------------------------------
%% attribute options(5) with type OCTET STRING OPTIONAL
%%-------------------------------------------------
   {EncBytes5,EncLen5} =  case Cindex5 of
         asn1__MISSING_IN_MAP -> {<<>>,0};
         _ ->
            encode_restricted_string(Cindex5, [<<132>>])
       end,

   BytesSoFar = [EncBytes1, EncBytes2, EncBytes3, EncBytes4, EncBytes5],
LenSoFar = EncLen1 + EncLen2 + EncLen3 + EncLen4 + EncLen5,
encode_tags(TagIn, BytesSoFar, LenSoFar).


dec_HeaderForwardJoin(Tlv) ->
   dec_HeaderForwardJoin(Tlv, [16]).

dec_HeaderForwardJoin(Tlv, TagIn) ->
   %%-------------------------------------------------
   %% decode tag and length 
   %%-------------------------------------------------
Tlv1 = match_tags(Tlv, TagIn),

%%-------------------------------------------------
%% attribute namespace(1) with type UTF8String
%%-------------------------------------------------
[V1|Tlv2] = Tlv1, 
Term1 = decode_UTF8_string(V1, [131072]),

%%-------------------------------------------------
%% attribute ulid(2) with type OCTET STRING
%%-------------------------------------------------
[V2|Tlv3] = Tlv2, 
Term2 = begin
Val1 = decode_octet_string(V2, [131073]),
C1 = byte_size(Val1),
if C1 =:= 26 ->
Val1;
true ->
exit({error,{asn1,bad_range}})
end
end,

%%-------------------------------------------------
%% attribute joinType(3) with type UTF8String
%%-------------------------------------------------
[V3|Tlv4] = Tlv3, 
Term3 = decode_UTF8_string(V3, [131074]),

%%-------------------------------------------------
%% attribute lock(4) with type OCTET STRING
%%-------------------------------------------------
[V4|Tlv5] = Tlv4, 
Term4 = begin
Val2 = decode_octet_string(V4, [131075]),
C2 = byte_size(Val2),
if C2 =:= 24 ->
Val2;
true ->
exit({error,{asn1,bad_range}})
end
end,

%%-------------------------------------------------
%% attribute options(5) with type OCTET STRING OPTIONAL
%%-------------------------------------------------
{Term5,Tlv6} = case Tlv5 of
[{131076,V5}|TempTlv6] ->
    {decode_octet_string(V5, []), TempTlv6};
    _ ->
        { asn1_NOVALUE, Tlv5}
end,

case Tlv6 of
[] -> true;_ -> exit({error,{asn1, {unexpected,Tlv6}}}) % extra fields not allowed
end,
Res1 = #{namespace=>Term1,ulid=>Term2,joinType=>Term3,lock=>Term4},
Res2 = case Term5 of
  asn1_NOVALUE -> Res1;
  _ -> Res1#{options=>Term5}
end,
Res2.


%%================================
%%  HeaderForwardJoinAck
%%================================
enc_HeaderForwardJoinAck(Val) ->
    enc_HeaderForwardJoinAck(Val, [<<48>>]).

enc_HeaderForwardJoinAck(Val, TagIn) ->
#{result:=Cindex1,joinType:=Cindex2} = Val,

%%-------------------------------------------------
%% attribute result(1) with type ENUMERATED
%%-------------------------------------------------
   {EncBytes1,EncLen1} = case Cindex1 of
ok -> encode_tags([<<128>>], [0], 1);
'namespace-full' -> encode_tags([<<128>>], [1], 1);
'duplicate-node' -> encode_tags([<<128>>], [2], 1);
'invalid-lock' -> encode_tags([<<128>>], [3], 1);
'leader-unavailable' -> encode_tags([<<128>>], [4], 1);
Enumval1 -> exit({error,{asn1, {enumerated_not_in_range,Enumval1}}})
end,

%%-------------------------------------------------
%% attribute joinType(2) with type UTF8String
%%-------------------------------------------------
   {EncBytes2,EncLen2} = encode_UTF8_string(Cindex2, [<<129>>]),

   BytesSoFar = [EncBytes1, EncBytes2],
LenSoFar = EncLen1 + EncLen2,
encode_tags(TagIn, BytesSoFar, LenSoFar).


dec_HeaderForwardJoinAck(Tlv) ->
   dec_HeaderForwardJoinAck(Tlv, [16]).

dec_HeaderForwardJoinAck(Tlv, TagIn) ->
   %%-------------------------------------------------
   %% decode tag and length 
   %%-------------------------------------------------
Tlv1 = match_tags(Tlv, TagIn),

%%-------------------------------------------------
%% attribute result(1) with type ENUMERATED
%%-------------------------------------------------
[V1|Tlv2] = Tlv1, 
Term1 = case decode_integer(V1, [131072]) of
0 -> ok;
1 -> 'namespace-full';
2 -> 'duplicate-node';
3 -> 'invalid-lock';
4 -> 'leader-unavailable';
Default1 -> exit({error,{asn1,{illegal_enumerated,Default1}}})
end,

%%-------------------------------------------------
%% attribute joinType(2) with type UTF8String
%%-------------------------------------------------
[V2|Tlv3] = Tlv2, 
Term2 = decode_UTF8_string(V2, [131073]),

case Tlv3 of
[] -> true;_ -> exit({error,{asn1, {unexpected,Tlv3}}}) % extra fields not allowed
end,
Res1 = #{result=>Term1,joinType=>Term2},
Res1.


%%================================
%%  ExchangeIn
%%================================
enc_ExchangeIn(Val) ->
    enc_ExchangeIn(Val, [<<48>>]).

enc_ExchangeIn(Val, TagIn) ->
#{proposedSample:=Cindex1} = Val,

%%-------------------------------------------------
%% attribute proposedSample(1) with type SEQUENCE OF
%%-------------------------------------------------
   {EncBytes1,EncLen1} = 'enc_ExchangeIn_proposedSample'(Cindex1, [<<160>>]),

   BytesSoFar = [EncBytes1],
LenSoFar = EncLen1,
encode_tags(TagIn, BytesSoFar, LenSoFar).



%%================================
%%  ExchangeIn_proposedSample
%%================================
enc_ExchangeIn_proposedSample(Val, TagIn) ->
      {EncBytes,EncLen} = 'enc_ExchangeIn_proposedSample_components'(Val,[],0),
   encode_tags(TagIn, EncBytes, EncLen).

'enc_ExchangeIn_proposedSample_components'([], AccBytes, AccLen) -> 
   {lists:reverse(AccBytes),AccLen};

'enc_ExchangeIn_proposedSample_components'([H|T],AccBytes, AccLen) ->
   {EncBytes,EncLen} = 'enc_ExchangeEntry'(H, [<<48>>]),
   'enc_ExchangeIn_proposedSample_components'(T,[EncBytes|AccBytes], AccLen + EncLen).



dec_ExchangeIn(Tlv) ->
   dec_ExchangeIn(Tlv, [16]).

dec_ExchangeIn(Tlv, TagIn) ->
   %%-------------------------------------------------
   %% decode tag and length 
   %%-------------------------------------------------
Tlv1 = match_tags(Tlv, TagIn),

%%-------------------------------------------------
%% attribute proposedSample(1) with type SEQUENCE OF
%%-------------------------------------------------
[V1|Tlv2] = Tlv1, 
Term1 = 'dec_ExchangeIn_proposedSample'(V1, [131072]),

case Tlv2 of
[] -> true;_ -> exit({error,{asn1, {unexpected,Tlv2}}}) % extra fields not allowed
end,
Res1 = #{proposedSample=>Term1},
Res1.
'dec_ExchangeIn_proposedSample'(Tlv, TagIn) ->
   %%-------------------------------------------------
   %% decode tag and length 
   %%-------------------------------------------------
Tlv1 = match_tags(Tlv, TagIn),
['dec_ExchangeEntry'(V1, [16]) || V1 <- Tlv1].




%%================================
%%  ExchangeOut
%%================================
enc_ExchangeOut(Val) ->
    enc_ExchangeOut(Val, [<<48>>]).

enc_ExchangeOut(Val, TagIn) ->
#{proposedSample:=Cindex1} = Val,

%%-------------------------------------------------
%% attribute proposedSample(1) with type SEQUENCE OF
%%-------------------------------------------------
   {EncBytes1,EncLen1} = 'enc_ExchangeOut_proposedSample'(Cindex1, [<<160>>]),

   BytesSoFar = [EncBytes1],
LenSoFar = EncLen1,
encode_tags(TagIn, BytesSoFar, LenSoFar).



%%================================
%%  ExchangeOut_proposedSample
%%================================
enc_ExchangeOut_proposedSample(Val, TagIn) ->
      {EncBytes,EncLen} = 'enc_ExchangeOut_proposedSample_components'(Val,[],0),
   encode_tags(TagIn, EncBytes, EncLen).

'enc_ExchangeOut_proposedSample_components'([], AccBytes, AccLen) -> 
   {lists:reverse(AccBytes),AccLen};

'enc_ExchangeOut_proposedSample_components'([H|T],AccBytes, AccLen) ->
   {EncBytes,EncLen} = 'enc_ExchangeEntry'(H, [<<48>>]),
   'enc_ExchangeOut_proposedSample_components'(T,[EncBytes|AccBytes], AccLen + EncLen).



dec_ExchangeOut(Tlv) ->
   dec_ExchangeOut(Tlv, [16]).

dec_ExchangeOut(Tlv, TagIn) ->
   %%-------------------------------------------------
   %% decode tag and length 
   %%-------------------------------------------------
Tlv1 = match_tags(Tlv, TagIn),

%%-------------------------------------------------
%% attribute proposedSample(1) with type SEQUENCE OF
%%-------------------------------------------------
[V1|Tlv2] = Tlv1, 
Term1 = 'dec_ExchangeOut_proposedSample'(V1, [131072]),

case Tlv2 of
[] -> true;_ -> exit({error,{asn1, {unexpected,Tlv2}}}) % extra fields not allowed
end,
Res1 = #{proposedSample=>Term1},
Res1.
'dec_ExchangeOut_proposedSample'(Tlv, TagIn) ->
   %%-------------------------------------------------
   %% decode tag and length 
   %%-------------------------------------------------
Tlv1 = match_tags(Tlv, TagIn),
['dec_ExchangeEntry'(V1, [16]) || V1 <- Tlv1].




%%================================
%%  ExchangeAccept
%%================================
enc_ExchangeAccept(Val) ->
    enc_ExchangeAccept(Val, [<<48>>]).

enc_ExchangeAccept(Val, TagIn) ->

   BytesSoFar = [],
LenSoFar = 0,
encode_tags(TagIn, BytesSoFar, LenSoFar).


dec_ExchangeAccept(Tlv) ->
   dec_ExchangeAccept(Tlv, [16]).

dec_ExchangeAccept(Tlv, TagIn) ->
   %%-------------------------------------------------
   %% decode tag and length 
   %%-------------------------------------------------
match_tags(Tlv, TagIn),


   #{}.



%%================================
%%  ExchangeCancelled
%%================================
enc_ExchangeCancelled(Val) ->
    enc_ExchangeCancelled(Val, [<<48>>]).

enc_ExchangeCancelled(Val, TagIn) ->
#{namespace:=Cindex1,reason:=Cindex2} = Val,

%%-------------------------------------------------
%% attribute namespace(1) with type UTF8String
%%-------------------------------------------------
   {EncBytes1,EncLen1} = encode_UTF8_string(Cindex1, [<<128>>]),

%%-------------------------------------------------
%% attribute reason(2) with type ENUMERATED
%%-------------------------------------------------
   {EncBytes2,EncLen2} = case Cindex2 of
normal -> encode_tags([<<129>>], [0], 1);
'protocol-error' -> encode_tags([<<129>>], [1], 1);
timeout -> encode_tags([<<129>>], [2], 1);
'resource-limit' -> encode_tags([<<129>>], [3], 1);
'network-error' -> encode_tags([<<129>>], [4], 1);
shutdown -> encode_tags([<<129>>], [5], 1);
Enumval2 -> exit({error,{asn1, {enumerated_not_in_range,Enumval2}}})
end,

   BytesSoFar = [EncBytes1, EncBytes2],
LenSoFar = EncLen1 + EncLen2,
encode_tags(TagIn, BytesSoFar, LenSoFar).


dec_ExchangeCancelled(Tlv) ->
   dec_ExchangeCancelled(Tlv, [16]).

dec_ExchangeCancelled(Tlv, TagIn) ->
   %%-------------------------------------------------
   %% decode tag and length 
   %%-------------------------------------------------
Tlv1 = match_tags(Tlv, TagIn),

%%-------------------------------------------------
%% attribute namespace(1) with type UTF8String
%%-------------------------------------------------
[V1|Tlv2] = Tlv1, 
Term1 = decode_UTF8_string(V1, [131072]),

%%-------------------------------------------------
%% attribute reason(2) with type ENUMERATED
%%-------------------------------------------------
[V2|Tlv3] = Tlv2, 
Term2 = case decode_integer(V2, [131073]) of
0 -> normal;
1 -> 'protocol-error';
2 -> timeout;
3 -> 'resource-limit';
4 -> 'network-error';
5 -> shutdown;
Default1 -> exit({error,{asn1,{illegal_enumerated,Default1}}})
end,

case Tlv3 of
[] -> true;_ -> exit({error,{asn1, {unexpected,Tlv3}}}) % extra fields not allowed
end,
Res1 = #{namespace=>Term1,reason=>Term2},
Res1.


%%================================
%%  NodeQuitting
%%================================
enc_NodeQuitting(Val) ->
    enc_NodeQuitting(Val, [<<48>>]).

enc_NodeQuitting(Val, TagIn) ->
#{reason:=Cindex1} = Val,

%%-------------------------------------------------
%% attribute reason(1) with type ENUMERATED
%%-------------------------------------------------
   {EncBytes1,EncLen1} = case Cindex1 of
normal -> encode_tags([<<128>>], [0], 1);
'protocol-error' -> encode_tags([<<128>>], [1], 1);
timeout -> encode_tags([<<128>>], [2], 1);
'resource-limit' -> encode_tags([<<128>>], [3], 1);
'network-error' -> encode_tags([<<128>>], [4], 1);
shutdown -> encode_tags([<<128>>], [5], 1);
Enumval1 -> exit({error,{asn1, {enumerated_not_in_range,Enumval1}}})
end,

   BytesSoFar = [EncBytes1],
LenSoFar = EncLen1,
encode_tags(TagIn, BytesSoFar, LenSoFar).


dec_NodeQuitting(Tlv) ->
   dec_NodeQuitting(Tlv, [16]).

dec_NodeQuitting(Tlv, TagIn) ->
   %%-------------------------------------------------
   %% decode tag and length 
   %%-------------------------------------------------
Tlv1 = match_tags(Tlv, TagIn),

%%-------------------------------------------------
%% attribute reason(1) with type ENUMERATED
%%-------------------------------------------------
[V1|Tlv2] = Tlv1, 
Term1 = case decode_integer(V1, [131072]) of
0 -> normal;
1 -> 'protocol-error';
2 -> timeout;
3 -> 'resource-limit';
4 -> 'network-error';
5 -> shutdown;
Default1 -> exit({error,{asn1,{illegal_enumerated,Default1}}})
end,

case Tlv2 of
[] -> true;_ -> exit({error,{asn1, {unexpected,Tlv2}}}) % extra fields not allowed
end,
Res1 = #{reason=>Term1},
Res1.


%%================================
%%  ChangeLock
%%================================
enc_ChangeLock(Val) ->
    enc_ChangeLock(Val, [<<48>>]).

enc_ChangeLock(Val, TagIn) ->
#{newLock:=Cindex1,currentLock:=Cindex2} = Val,

%%-------------------------------------------------
%% attribute newLock(1) with type OCTET STRING
%%-------------------------------------------------
   {EncBytes1,EncLen1} = encode_restricted_string(Cindex1, [<<128>>]),

%%-------------------------------------------------
%% attribute currentLock(2) with type OCTET STRING
%%-------------------------------------------------
   {EncBytes2,EncLen2} = encode_restricted_string(Cindex2, [<<129>>]),

   BytesSoFar = [EncBytes1, EncBytes2],
LenSoFar = EncLen1 + EncLen2,
encode_tags(TagIn, BytesSoFar, LenSoFar).


dec_ChangeLock(Tlv) ->
   dec_ChangeLock(Tlv, [16]).

dec_ChangeLock(Tlv, TagIn) ->
   %%-------------------------------------------------
   %% decode tag and length 
   %%-------------------------------------------------
Tlv1 = match_tags(Tlv, TagIn),

%%-------------------------------------------------
%% attribute newLock(1) with type OCTET STRING
%%-------------------------------------------------
[V1|Tlv2] = Tlv1, 
Term1 = begin
Val1 = decode_octet_string(V1, [131072]),
C1 = byte_size(Val1),
if C1 =:= 24 ->
Val1;
true ->
exit({error,{asn1,bad_range}})
end
end,

%%-------------------------------------------------
%% attribute currentLock(2) with type OCTET STRING
%%-------------------------------------------------
[V2|Tlv3] = Tlv2, 
Term2 = begin
Val2 = decode_octet_string(V2, [131073]),
C2 = byte_size(Val2),
if C2 =:= 24 ->
Val2;
true ->
exit({error,{asn1,bad_range}})
end
end,

case Tlv3 of
[] -> true;_ -> exit({error,{asn1, {unexpected,Tlv3}}}) % extra fields not allowed
end,
Res1 = #{newLock=>Term1,currentLock=>Term2},
Res1.


%%================================
%%  OntologyHistory
%%================================
enc_OntologyHistory(Val) ->
    enc_OntologyHistory(Val, [<<48>>]).

enc_OntologyHistory(Val, TagIn) ->
#{namespace:=Cindex1,oldestIndex:=Cindex2,youngerIndex:=Cindex3,transactions:=Cindex4} = Val,

%%-------------------------------------------------
%% attribute namespace(1) with type UTF8String
%%-------------------------------------------------
   {EncBytes1,EncLen1} = encode_UTF8_string(Cindex1, [<<128>>]),

%%-------------------------------------------------
%% attribute oldestIndex(2) with type INTEGER
%%-------------------------------------------------
   {EncBytes2,EncLen2} = encode_integer(Cindex2, [<<129>>]),

%%-------------------------------------------------
%% attribute youngerIndex(3) with type INTEGER
%%-------------------------------------------------
   {EncBytes3,EncLen3} = encode_integer(Cindex3, [<<130>>]),

%%-------------------------------------------------
%% attribute transactions(4) with type OCTET STRING
%%-------------------------------------------------
   {EncBytes4,EncLen4} = encode_restricted_string(Cindex4, [<<131>>]),

   BytesSoFar = [EncBytes1, EncBytes2, EncBytes3, EncBytes4],
LenSoFar = EncLen1 + EncLen2 + EncLen3 + EncLen4,
encode_tags(TagIn, BytesSoFar, LenSoFar).


dec_OntologyHistory(Tlv) ->
   dec_OntologyHistory(Tlv, [16]).

dec_OntologyHistory(Tlv, TagIn) ->
   %%-------------------------------------------------
   %% decode tag and length 
   %%-------------------------------------------------
Tlv1 = match_tags(Tlv, TagIn),

%%-------------------------------------------------
%% attribute namespace(1) with type UTF8String
%%-------------------------------------------------
[V1|Tlv2] = Tlv1, 
Term1 = decode_UTF8_string(V1, [131072]),

%%-------------------------------------------------
%% attribute oldestIndex(2) with type INTEGER
%%-------------------------------------------------
[V2|Tlv3] = Tlv2, 
Term2 = decode_integer(V2, [131073]),

%%-------------------------------------------------
%% attribute youngerIndex(3) with type INTEGER
%%-------------------------------------------------
[V3|Tlv4] = Tlv3, 
Term3 = decode_integer(V3, [131074]),

%%-------------------------------------------------
%% attribute transactions(4) with type OCTET STRING
%%-------------------------------------------------
[V4|Tlv5] = Tlv4, 
Term4 = decode_octet_string(V4, [131075]),

case Tlv5 of
[] -> true;_ -> exit({error,{asn1, {unexpected,Tlv5}}}) % extra fields not allowed
end,
Res1 = #{namespace=>Term1,oldestIndex=>Term2,youngerIndex=>Term3,transactions=>Term4},
Res1.


%%================================
%%  EptoMessage
%%================================
enc_EptoMessage(Val) ->
    enc_EptoMessage(Val, [<<48>>]).

enc_EptoMessage(Val, TagIn) ->
#{payload:=Cindex1} = Val,

%%-------------------------------------------------
%% attribute payload(1) with type OCTET STRING
%%-------------------------------------------------
   {EncBytes1,EncLen1} = encode_restricted_string(Cindex1, [<<128>>]),

   BytesSoFar = [EncBytes1],
LenSoFar = EncLen1,
encode_tags(TagIn, BytesSoFar, LenSoFar).


dec_EptoMessage(Tlv) ->
   dec_EptoMessage(Tlv, [16]).

dec_EptoMessage(Tlv, TagIn) ->
   %%-------------------------------------------------
   %% decode tag and length 
   %%-------------------------------------------------
Tlv1 = match_tags(Tlv, TagIn),

%%-------------------------------------------------
%% attribute payload(1) with type OCTET STRING
%%-------------------------------------------------
[V1|Tlv2] = Tlv1, 
Term1 = decode_octet_string(V1, [131072]),

case Tlv2 of
[] -> true;_ -> exit({error,{asn1, {unexpected,Tlv2}}}) % extra fields not allowed
end,
Res1 = #{payload=>Term1},
Res1.


%%================================
%%  SendForwardSubscription
%%================================
enc_SendForwardSubscription(Val) ->
    enc_SendForwardSubscription(Val, [<<48>>]).

enc_SendForwardSubscription(Val, TagIn) ->
#{subscriberNode:=Cindex1,lock:=Cindex2} = Val,

%%-------------------------------------------------
%% attribute subscriberNode(1)   External BBSVXProtocol:NodeEntry
%%-------------------------------------------------
   {EncBytes1,EncLen1} = 'enc_NodeEntry'(Cindex1, [<<160>>]),

%%-------------------------------------------------
%% attribute lock(2) with type OCTET STRING
%%-------------------------------------------------
   {EncBytes2,EncLen2} = encode_restricted_string(Cindex2, [<<129>>]),

   BytesSoFar = [EncBytes1, EncBytes2],
LenSoFar = EncLen1 + EncLen2,
encode_tags(TagIn, BytesSoFar, LenSoFar).


dec_SendForwardSubscription(Tlv) ->
   dec_SendForwardSubscription(Tlv, [16]).

dec_SendForwardSubscription(Tlv, TagIn) ->
   %%-------------------------------------------------
   %% decode tag and length 
   %%-------------------------------------------------
Tlv1 = match_tags(Tlv, TagIn),

%%-------------------------------------------------
%% attribute subscriberNode(1)   External BBSVXProtocol:NodeEntry
%%-------------------------------------------------
[V1|Tlv2] = Tlv1, 
Term1 = 'dec_NodeEntry'(V1, [131072]),

%%-------------------------------------------------
%% attribute lock(2) with type OCTET STRING
%%-------------------------------------------------
[V2|Tlv3] = Tlv2, 
Term2 = begin
Val1 = decode_octet_string(V2, [131073]),
C1 = byte_size(Val1),
if C1 =:= 24 ->
Val1;
true ->
exit({error,{asn1,bad_range}})
end
end,

case Tlv3 of
[] -> true;_ -> exit({error,{asn1, {unexpected,Tlv3}}}) % extra fields not allowed
end,
Res1 = #{subscriberNode=>Term1,lock=>Term2},
Res1.


%%================================
%%  OpenForwardJoin
%%================================
enc_OpenForwardJoin(Val) ->
    enc_OpenForwardJoin(Val, [<<48>>]).

enc_OpenForwardJoin(Val, TagIn) ->
#{subscriberNode:=Cindex1,lock:=Cindex2} = Val,

%%-------------------------------------------------
%% attribute subscriberNode(1)   External BBSVXProtocol:NodeEntry
%%-------------------------------------------------
   {EncBytes1,EncLen1} = 'enc_NodeEntry'(Cindex1, [<<160>>]),

%%-------------------------------------------------
%% attribute lock(2) with type OCTET STRING
%%-------------------------------------------------
   {EncBytes2,EncLen2} = encode_restricted_string(Cindex2, [<<129>>]),

   BytesSoFar = [EncBytes1, EncBytes2],
LenSoFar = EncLen1 + EncLen2,
encode_tags(TagIn, BytesSoFar, LenSoFar).


dec_OpenForwardJoin(Tlv) ->
   dec_OpenForwardJoin(Tlv, [16]).

dec_OpenForwardJoin(Tlv, TagIn) ->
   %%-------------------------------------------------
   %% decode tag and length 
   %%-------------------------------------------------
Tlv1 = match_tags(Tlv, TagIn),

%%-------------------------------------------------
%% attribute subscriberNode(1)   External BBSVXProtocol:NodeEntry
%%-------------------------------------------------
[V1|Tlv2] = Tlv1, 
Term1 = 'dec_NodeEntry'(V1, [131072]),

%%-------------------------------------------------
%% attribute lock(2) with type OCTET STRING
%%-------------------------------------------------
[V2|Tlv3] = Tlv2, 
Term2 = begin
Val1 = decode_octet_string(V2, [131073]),
C1 = byte_size(Val1),
if C1 =:= 24 ->
Val1;
true ->
exit({error,{asn1,bad_range}})
end
end,

case Tlv3 of
[] -> true;_ -> exit({error,{asn1, {unexpected,Tlv3}}}) % extra fields not allowed
end,
Res1 = #{subscriberNode=>Term1,lock=>Term2},
Res1.


%%================================
%%  BBSVXMessage
%%================================
enc_BBSVXMessage(Val) ->
    enc_BBSVXMessage(Val, []).

enc_BBSVXMessage(Val, TagIn) ->
   {EncBytes,EncLen} = case element(1,Val) of
      headerConnect ->
         'enc_HeaderConnect'(element(2,Val), [<<160>>]);
      headerConnectAck ->
         'enc_HeaderConnectAck'(element(2,Val), [<<161>>]);
      headerRegister ->
         'enc_HeaderRegister'(element(2,Val), [<<170>>]);
      headerRegisterAck ->
         'enc_HeaderRegisterAck'(element(2,Val), [<<171>>]);
      headerJoin ->
         'enc_HeaderJoin'(element(2,Val), [<<180>>]);
      headerJoinAck ->
         'enc_HeaderJoinAck'(element(2,Val), [<<181>>]);
      headerForwardJoin ->
         'enc_HeaderForwardJoin'(element(2,Val), [<<182>>]);
      headerForwardJoinAck ->
         'enc_HeaderForwardJoinAck'(element(2,Val), [<<183>>]);
      exchangeIn ->
         'enc_ExchangeIn'(element(2,Val), [<<190>>]);
      exchangeOut ->
         'enc_ExchangeOut'(element(2,Val), [<<191,31>>]);
      exchangeAccept ->
         'enc_ExchangeAccept'(element(2,Val), [<<191,32>>]);
      exchangeCancelled ->
         'enc_ExchangeCancelled'(element(2,Val), [<<191,33>>]);
      changeLock ->
         'enc_ChangeLock'(element(2,Val), [<<191,34>>]);
      nodeQuitting ->
         'enc_NodeQuitting'(element(2,Val), [<<191,40>>]);
      sendForwardSubscription ->
         'enc_SendForwardSubscription'(element(2,Val), [<<191,41>>]);
      openForwardJoin ->
         'enc_OpenForwardJoin'(element(2,Val), [<<191,42>>]);
      ontologyHistory ->
         'enc_OntologyHistory'(element(2,Val), [<<191,50>>]);
      eptoMessage ->
         'enc_EptoMessage'(element(2,Val), [<<191,51>>]);
      Else -> 
         exit({error,{asn1,{invalid_choice_type,Else}}})
   end,

encode_tags(TagIn, EncBytes, EncLen).




dec_BBSVXMessage(Tlv) ->
   dec_BBSVXMessage(Tlv, []).

dec_BBSVXMessage(Tlv, TagIn) ->
Tlv1 = match_tags(Tlv, TagIn),
case (case Tlv1 of [CtempTlv1] -> CtempTlv1; _ -> Tlv1 end) of

%% 'headerConnect'
    {131072, V1} -> 
        {headerConnect, 'dec_HeaderConnect'(V1, [])};


%% 'headerConnectAck'
    {131073, V1} -> 
        {headerConnectAck, 'dec_HeaderConnectAck'(V1, [])};


%% 'headerRegister'
    {131082, V1} -> 
        {headerRegister, 'dec_HeaderRegister'(V1, [])};


%% 'headerRegisterAck'
    {131083, V1} -> 
        {headerRegisterAck, 'dec_HeaderRegisterAck'(V1, [])};


%% 'headerJoin'
    {131092, V1} -> 
        {headerJoin, 'dec_HeaderJoin'(V1, [])};


%% 'headerJoinAck'
    {131093, V1} -> 
        {headerJoinAck, 'dec_HeaderJoinAck'(V1, [])};


%% 'headerForwardJoin'
    {131094, V1} -> 
        {headerForwardJoin, 'dec_HeaderForwardJoin'(V1, [])};


%% 'headerForwardJoinAck'
    {131095, V1} -> 
        {headerForwardJoinAck, 'dec_HeaderForwardJoinAck'(V1, [])};


%% 'exchangeIn'
    {131102, V1} -> 
        {exchangeIn, 'dec_ExchangeIn'(V1, [])};


%% 'exchangeOut'
    {131103, V1} -> 
        {exchangeOut, 'dec_ExchangeOut'(V1, [])};


%% 'exchangeAccept'
    {131104, V1} -> 
        {exchangeAccept, 'dec_ExchangeAccept'(V1, [])};


%% 'exchangeCancelled'
    {131105, V1} -> 
        {exchangeCancelled, 'dec_ExchangeCancelled'(V1, [])};


%% 'changeLock'
    {131106, V1} -> 
        {changeLock, 'dec_ChangeLock'(V1, [])};


%% 'nodeQuitting'
    {131112, V1} -> 
        {nodeQuitting, 'dec_NodeQuitting'(V1, [])};


%% 'sendForwardSubscription'
    {131113, V1} -> 
        {sendForwardSubscription, 'dec_SendForwardSubscription'(V1, [])};


%% 'openForwardJoin'
    {131114, V1} -> 
        {openForwardJoin, 'dec_OpenForwardJoin'(V1, [])};


%% 'ontologyHistory'
    {131122, V1} -> 
        {ontologyHistory, 'dec_OntologyHistory'(V1, [])};


%% 'eptoMessage'
    {131123, V1} -> 
        {eptoMessage, 'dec_EptoMessage'(V1, [])};

      Else -> 
         exit({error,{asn1,{invalid_choice_tag,Else}}})
   end
.

%%%
%%% Run-time functions.
%%%

'dialyzer-suppressions'(Arg) ->
    ok.

ber_decode_nif(B) ->
    asn1rt_nif:decode_ber_tlv(B).

collect_parts(TlvList) ->
    collect_parts(TlvList, []).

collect_parts([{_, L} | Rest], Acc) when is_list(L) ->
    collect_parts(Rest, [collect_parts(L) | Acc]);
collect_parts([{3, <<Unused,Bits/binary>>} | Rest], _Acc) ->
    collect_parts_bit(Rest, [Bits], Unused);
collect_parts([{_T, V} | Rest], Acc) ->
    collect_parts(Rest, [V | Acc]);
collect_parts([], Acc) ->
    list_to_binary(lists:reverse(Acc)).

collect_parts_bit([{3, <<Unused,Bits/binary>>} | Rest], Acc, Uacc) ->
    collect_parts_bit(Rest, [Bits | Acc], Unused + Uacc);
collect_parts_bit([], Acc, Uacc) ->
    list_to_binary([Uacc | lists:reverse(Acc)]).

decode_UTF8_string(Tlv, TagsIn) ->
    Val = match_tags(Tlv, TagsIn),
    case Val of
        [_ | _] = PartList ->
            collect_parts(PartList);
        Bin ->
            Bin
    end.

decode_integer(Tlv, TagIn) ->
    Bin = match_tags(Tlv, TagIn),
    Len = byte_size(Bin),
    <<Int:Len/signed-unit:8>> = Bin,
    Int.

decode_null(Tlv, Tags) ->
    Val = match_tags(Tlv, Tags),
    case Val of
        <<>> ->
            'NULL';
        _ ->
            exit({error, {asn1, {decode_null, Val}}})
    end.

decode_octet_string(Tlv, TagsIn) ->
    Bin = match_and_collect(Tlv, TagsIn),
    binary:copy(Bin).

encode_UTF8_string(UTF8String, TagIn) when is_binary(UTF8String) ->
    encode_tags(TagIn, UTF8String, byte_size(UTF8String));
encode_UTF8_string(UTF8String, TagIn) ->
    encode_tags(TagIn, UTF8String, length(UTF8String)).

encode_integer(Val) ->
    Bytes =
        if
            Val >= 0 ->
                encode_integer_pos(Val, []);
            true ->
                encode_integer_neg(Val, [])
        end,
    {Bytes, length(Bytes)}.

encode_integer(Val, Tag) when is_integer(Val) ->
    encode_tags(Tag, encode_integer(Val));
encode_integer(Val, _Tag) ->
    exit({error, {asn1, {encode_integer, Val}}}).

encode_integer_neg(-1, [B1 | _T] = L) when B1 > 127 ->
    L;
encode_integer_neg(N, Acc) ->
    encode_integer_neg(N bsr 8, [N band 255 | Acc]).

encode_integer_pos(0, [B | _Acc] = L) when B < 128 ->
    L;
encode_integer_pos(N, Acc) ->
    encode_integer_pos(N bsr 8, [N band 255 | Acc]).

encode_length(L) when L =< 127 ->
    {[L], 1};
encode_length(L) ->
    Oct = minimum_octets(L),
    Len = length(Oct),
    if
        Len =< 126 ->
            {[128 bor Len | Oct], Len + 1};
        true ->
            exit({error, {asn1, too_long_length_oct, Len}})
    end.

encode_null(_Val, TagIn) ->
    encode_tags(TagIn, [], 0).

encode_restricted_string(OctetList, TagIn) when is_binary(OctetList) ->
    encode_tags(TagIn, OctetList, byte_size(OctetList));
encode_restricted_string(OctetList, TagIn) when is_list(OctetList) ->
    encode_tags(TagIn, OctetList, length(OctetList)).

encode_tags(TagIn, {BytesSoFar, LenSoFar}) ->
    encode_tags(TagIn, BytesSoFar, LenSoFar).

encode_tags([Tag | Trest], BytesSoFar, LenSoFar) ->
    {Bytes2, L2} = encode_length(LenSoFar),
    encode_tags(Trest,
                [Tag, Bytes2 | BytesSoFar],
                LenSoFar + byte_size(Tag) + L2);
encode_tags([], BytesSoFar, LenSoFar) ->
    {BytesSoFar, LenSoFar}.

match_and_collect(Tlv, TagsIn) ->
    Val = match_tags(Tlv, TagsIn),
    case Val of
        [_ | _] = PartList ->
            collect_parts(PartList);
        Bin when is_binary(Bin) ->
            Bin
    end.

match_tags({T, V}, [T]) ->
    V;
match_tags({T, V}, [T | Tt]) ->
    match_tags(V, Tt);
match_tags([{T, V}], [T | Tt]) ->
    match_tags(V, Tt);
match_tags([{T, _V} | _] = Vlist, [T]) ->
    Vlist;
match_tags(Tlv, []) ->
    Tlv;
match_tags({Tag, _V} = Tlv, [T | _Tt]) ->
    exit({error, {asn1, {wrong_tag, {{expected, T}, {got, Tag, Tlv}}}}}).

minimum_octets(0, Acc) ->
    Acc;
minimum_octets(Val, Acc) ->
    minimum_octets(Val bsr 8, [Val band 255 | Acc]).

minimum_octets(Val) ->
    minimum_octets(Val, []).
